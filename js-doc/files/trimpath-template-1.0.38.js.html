<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>trimpath-template-1.0.38.js - Bristleback Client API</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http:&#x2F;&#x2F;bristleback.pl&#x2F;img&#x2F;logo.png" title="Bristleback Client API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.2.1</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Bristleback.Client.html">Bristleback.Client</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.CONNECTOR.html">Bristleback.CONNECTOR</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.Console.html">Bristleback.Console</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.controller.Action.html">Bristleback.controller.Action</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.controller.ActionCallback.html">Bristleback.controller.ActionCallback</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.controller.ActionClass.html">Bristleback.controller.ActionClass</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.controller.ActionController.html">Bristleback.controller.ActionController</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.controller.ActionExceptionHandler.html">Bristleback.controller.ActionExceptionHandler</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.controller.ClientActionClass.html">Bristleback.controller.ClientActionClass</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.LOCAL_HOSTNAME.html">Bristleback.LOCAL_HOSTNAME</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.utils.html">Bristleback.utils</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/Bristleback.html">Bristleback</a></li>
            
                <li><a href="..&#x2F;modules/controller.html">controller</a></li>
            
                <li><a href="..&#x2F;modules/core.html">core</a></li>
            
                <li><a href="..&#x2F;modules/serialization.html">serialization</a></li>
            
                <li><a href="..&#x2F;modules/utils.html">utils</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: trimpath-template-1.0.38.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 * TrimPath Template. Release 1.0.38.
 * Copyright (C) 2004, 2005 Metaha.
 *
 * TrimPath Template is licensed under the GNU General Public License
 * and the Apache License, Version 2.0, as follows:
 *
 * This program is free software; you can redistribute it and&#x2F;or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed WITHOUT ANY WARRANTY; without even the
 * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http:&#x2F;&#x2F;www.apache.org&#x2F;licenses&#x2F;LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *&#x2F;
var TrimPath;

&#x2F;&#x2F; TODO: Debugging mode vs stop-on-error mode - runtime flag.
&#x2F;&#x2F; TODO: Handle || (or) characters and backslashes.
&#x2F;&#x2F; TODO: Add more modifiers.

(function() {               &#x2F;&#x2F; Using a closure to keep global namespace clean.
  if (TrimPath == null)
    TrimPath = new Object();
  if (TrimPath.evalEx == null)
    TrimPath.evalEx = function(src) {
      return eval(src);
    };

  var UNDEFINED;
  if (Array.prototype.pop == null)  &#x2F;&#x2F; IE 5.x fix from Igor Poteryaev.
    Array.prototype.pop = function() {
      if (this.length === 0) {
        return UNDEFINED;
      }
      return this[--this.length];
    };
  if (Array.prototype.push == null) &#x2F;&#x2F; IE 5.x fix from Igor Poteryaev.
    Array.prototype.push = function() {
      for (var i = 0; i &lt; arguments.length; ++i) {
        this[this.length] = arguments[i];
      }
      return this.length;
    };

  TrimPath.parseTemplate = function(tmplContent, optTmplName, optEtc) {
    if (optEtc == null)
      optEtc = TrimPath.parseTemplate_etc;
    var funcSrc = parse(tmplContent, optTmplName, optEtc);
    var func = TrimPath.evalEx(funcSrc, optTmplName, 1);
    if (func != null)
      return new optEtc.Template(optTmplName, tmplContent, funcSrc, func, optEtc);
    return null;
  }

  try {
    String.prototype.process = function(context, optFlags) {
      var template = TrimPath.parseTemplate(this, null);
      if (template != null)
        return template.process(context, optFlags);
      return this;
    }
  } catch (e) { &#x2F;&#x2F; Swallow exception, such as when String.prototype is sealed.
  }

  TrimPath.parseTemplate_etc = {};            &#x2F;&#x2F; Exposed for extensibility.
  TrimPath.parseTemplate_etc.statementTag = &quot;forelse|for|if|elseif|else|var|macro&quot;;
  TrimPath.parseTemplate_etc.statementDef = { &#x2F;&#x2F; Lookup table for statement tags.
    &quot;if&quot;     : { delta:  1, prefix: &quot;if (&quot;, suffix: &quot;) {&quot;, paramMin: 1 },
    &quot;else&quot;   : { delta:  0, prefix: &quot;} else {&quot; },
    &quot;elseif&quot; : { delta:  0, prefix: &quot;} else if (&quot;, suffix: &quot;) {&quot;, paramDefault: &quot;true&quot; },
    &quot;&#x2F;if&quot;    : { delta: -1, prefix: &quot;}&quot; },
    &quot;for&quot;    : { delta:  1, paramMin: 3,
      prefixFunc : function(stmtParts, state, tmplName, etc) {
        if (stmtParts[2] != &quot;in&quot;)
          throw new etc.ParseError(tmplName, state.line, &quot;bad for loop statement: &quot; + stmtParts.join(&#x27; &#x27;));
        var iterVar = stmtParts[1];
        var listVar = &quot;__LIST__&quot; + iterVar;
        return [ &quot;var &quot;, listVar, &quot; = &quot;, stmtParts[3], &quot;;&quot;,
          &#x2F;&#x2F; Fix from Ross Shaull for hash looping, make sure that we have an array of loop lengths to treat like a stack.
          &quot;var __LENGTH_STACK__;&quot;,
          &quot;if (typeof(__LENGTH_STACK__) == &#x27;undefined&#x27; || !__LENGTH_STACK__.length) __LENGTH_STACK__ = new Array();&quot;,
          &quot;__LENGTH_STACK__[__LENGTH_STACK__.length] = 0;&quot;, &#x2F;&#x2F; Push a new for-loop onto the stack of loop lengths.
          &quot;if ((&quot;, listVar, &quot;) != null) { &quot;,
          &quot;var &quot;, iterVar, &quot;_ct = 0;&quot;,       &#x2F;&#x2F; iterVar_ct variable, added by B. Bittman
          &quot;for (var &quot;, iterVar, &quot;_index in &quot;, listVar, &quot;) { &quot;,
          iterVar, &quot;_ct++;&quot;,
          &quot;if (typeof(&quot;, listVar, &quot;[&quot;, iterVar, &quot;_index]) == &#x27;function&#x27;) {continue;}&quot;, &#x2F;&#x2F; IE 5.x fix from Igor Poteryaev.
          &quot;__LENGTH_STACK__[__LENGTH_STACK__.length - 1]++;&quot;,
          &quot;var &quot;, iterVar, &quot; = &quot;, listVar, &quot;[&quot;, iterVar, &quot;_index];&quot; ].join(&quot;&quot;);
      } },
    &quot;forelse&quot; : { delta:  0, prefix: &quot;} } if (__LENGTH_STACK__[__LENGTH_STACK__.length - 1] == 0) { if (&quot;, suffix: &quot;) {&quot;, paramDefault: &quot;true&quot; },
    &quot;&#x2F;for&quot;    : { delta: -1, prefix: &quot;} }; delete __LENGTH_STACK__[__LENGTH_STACK__.length - 1];&quot; }, &#x2F;&#x2F; Remove the just-finished for-loop from the stack of loop lengths.
    &quot;var&quot;     : { delta:  0, prefix: &quot;var &quot;, suffix: &quot;;&quot; },
    &quot;macro&quot;   : { delta:  1,
      prefixFunc : function(stmtParts, state, tmplName, etc) {
        var macroName = stmtParts[1].split(&#x27;(&#x27;)[0];
        return [ &quot;var &quot;, macroName, &quot; = function&quot;,
          stmtParts.slice(1).join(&#x27; &#x27;).substring(macroName.length),
          &quot;{ var _OUT_arr = []; var _OUT = { write: function(m) { if (m) _OUT_arr.push(m); } }; &quot; ].join(&#x27;&#x27;);
      } },
    &quot;&#x2F;macro&quot;  : { delta: -1, prefix: &quot; return _OUT_arr.join(&#x27;&#x27;); };&quot; }
  }
  TrimPath.parseTemplate_etc.modifierDef = {
    &quot;eat&quot;        : function(v) {
      return &quot;&quot;;
    },
    &quot;escape&quot;     : function(s) {
      return String(s).replace(&#x2F;&amp;&#x2F;g, &quot;&amp;amp;&quot;).replace(&#x2F;&lt;&#x2F;g, &quot;&amp;lt;&quot;).replace(&#x2F;&gt;&#x2F;g, &quot;&amp;gt;&quot;);
    },
    &quot;capitalize&quot; : function(s) {
      return String(s).toUpperCase();
    },
    &quot;default&quot;    : function(s, d) {
      return s != null ? s : d;
    }
  }
  TrimPath.parseTemplate_etc.modifierDef.h = TrimPath.parseTemplate_etc.modifierDef.escape;

  TrimPath.parseTemplate_etc.Template = function(tmplName, tmplContent, funcSrc, func, etc) {
    this.process = function(context, flags) {
      if (context == null)
        context = {};
      if (context._MODIFIERS == null)
        context._MODIFIERS = {};
      if (context.defined == null)
        context.defined = function(str) {
          return (context[str] != undefined);
        };
      for (var k in etc.modifierDef) {
        if (context._MODIFIERS[k] == null)
          context._MODIFIERS[k] = etc.modifierDef[k];
      }
      if (flags == null)
        flags = {};
      var resultArr = [];
      var resultOut = { write: function(m) {
        resultArr.push(m);
      } };
      try {
        func(resultOut, context, flags);
      } catch (e) {
        if (flags.throwExceptions == true)
          throw e;
        var result = new String(resultArr.join(&quot;&quot;) + &quot;[ERROR: &quot; + e.toString() + (e.message ? &#x27;; &#x27; + e.message : &#x27;&#x27;) + &quot;]&quot;);
        result[&quot;exception&quot;] = e;
        return result;
      }
      return resultArr.join(&quot;&quot;);
    }
    this.name = tmplName;
    this.source = tmplContent;
    this.sourceFunc = funcSrc;
    this.toString = function() {
      return &quot;TrimPath.Template [&quot; + tmplName + &quot;]&quot;;
    }
  }
  TrimPath.parseTemplate_etc.ParseError = function(name, line, message) {
    this.name = name;
    this.line = line;
    this.message = message;
  }
  TrimPath.parseTemplate_etc.ParseError.prototype.toString = function() {
    return (&quot;TrimPath template ParseError in &quot; + this.name + &quot;: line &quot; + this.line + &quot;, &quot; + this.message);
  }

  var parse = function(body, tmplName, etc) {
    body = cleanWhiteSpace(body);
    var funcText = [ &quot;var TrimPath_Template_TEMP = function(_OUT, _CONTEXT, _FLAGS) { with (_CONTEXT) {&quot; ];
    var state = { stack: [], line: 1 };                              &#x2F;&#x2F; TODO: Fix line number counting.
    var endStmtPrev = -1;
    while (endStmtPrev + 1 &lt; body.length) {
      var begStmt = endStmtPrev;
      &#x2F;&#x2F; Scan until we find some statement markup.
      begStmt = body.indexOf(&quot;{&quot;, begStmt + 1);
      while (begStmt &gt;= 0) {
        var endStmt = body.indexOf(&#x27;}&#x27;, begStmt + 1);
        var stmt = body.substring(begStmt, endStmt);
        var blockrx = stmt.match(&#x2F;^\{(cdata|minify|eval)&#x2F;); &#x2F;&#x2F; From B. Bittman, minify&#x2F;eval&#x2F;cdata implementation.
        if (blockrx) {
          var blockType = blockrx[1];
          var blockMarkerBeg = begStmt + blockType.length + 1;
          var blockMarkerEnd = body.indexOf(&#x27;}&#x27;, blockMarkerBeg);
          if (blockMarkerEnd &gt;= 0) {
            var blockMarker;
            if (blockMarkerEnd - blockMarkerBeg &lt;= 0) {
              blockMarker = &quot;{&#x2F;&quot; + blockType + &quot;}&quot;;
            } else {
              blockMarker = body.substring(blockMarkerBeg + 1, blockMarkerEnd);
            }

            var blockEnd = body.indexOf(blockMarker, blockMarkerEnd + 1);
            if (blockEnd &gt;= 0) {
              emitSectionText(body.substring(endStmtPrev + 1, begStmt), funcText);

              var blockText = body.substring(blockMarkerEnd + 1, blockEnd);
              if (blockType == &#x27;cdata&#x27;) {
                emitText(blockText, funcText);
              } else if (blockType == &#x27;minify&#x27;) {
                emitText(scrubWhiteSpace(blockText), funcText);
              } else if (blockType == &#x27;eval&#x27;) {
                if (blockText != null &amp;&amp; blockText.length &gt; 0) &#x2F;&#x2F; From B. Bittman, eval should not execute until process().
                  funcText.push(&#x27;_OUT.write( (function() { &#x27; + blockText + &#x27; })() );&#x27;);
              }
              begStmt = endStmtPrev = blockEnd + blockMarker.length - 1;
            }
          }
        } else if (body.charAt(begStmt - 1) != &#x27;$&#x27; &amp;&amp; &#x2F;&#x2F; Not an expression or backslashed,
          body.charAt(begStmt - 1) != &#x27;\\&#x27;) {              &#x2F;&#x2F; so check if it is a statement tag.
          var offset = (body.charAt(begStmt + 1) == &#x27;&#x2F;&#x27; ? 2 : 1); &#x2F;&#x2F; Close tags offset of 2 skips &#x27;&#x2F;&#x27;.
          &#x2F;&#x2F; 10 is larger than maximum statement tag length.
          if (body.substring(begStmt + offset, begStmt + 10 + offset).search(TrimPath.parseTemplate_etc.statementTag) == 0)
            break;                                              &#x2F;&#x2F; Found a match.
        }
        begStmt = body.indexOf(&quot;{&quot;, begStmt + 1);
      }
      if (begStmt &lt; 0)                              &#x2F;&#x2F; In &quot;a{for}c&quot;, begStmt will be 1.
        break;
      var endStmt = body.indexOf(&quot;}&quot;, begStmt + 1); &#x2F;&#x2F; In &quot;a{for}c&quot;, endStmt will be 5.
      if (endStmt &lt; 0)
        break;
      emitSectionText(body.substring(endStmtPrev + 1, begStmt), funcText);
      emitStatement(body.substring(begStmt, endStmt + 1), state, funcText, tmplName, etc);
      endStmtPrev = endStmt;
    }
    emitSectionText(body.substring(endStmtPrev + 1), funcText);
    if (state.stack.length != 0)
      throw new etc.ParseError(tmplName, state.line, &quot;unclosed, unmatched statement(s): &quot; + state.stack.join(&quot;,&quot;));
    funcText.push(&quot;}}; TrimPath_Template_TEMP&quot;);
    return funcText.join(&quot;&quot;);
  }

  var emitStatement = function(stmtStr, state, funcText, tmplName, etc) {
    var parts = stmtStr.slice(1, -1).split(&#x27; &#x27;);
    var stmt = etc.statementDef[parts[0]]; &#x2F;&#x2F; Here, parts[0] == for&#x2F;if&#x2F;else&#x2F;...
    if (stmt == null) {                    &#x2F;&#x2F; Not a real statement.
      emitSectionText(stmtStr, funcText);
      return;
    }
    if (stmt.delta &lt; 0) {
      if (state.stack.length &lt;= 0)
        throw new etc.ParseError(tmplName, state.line, &quot;close tag does not match any previous statement: &quot; + stmtStr);
      state.stack.pop();
    }
    if (stmt.delta &gt; 0)
      state.stack.push(stmtStr);

    if (stmt.paramMin != null &amp;&amp;
      stmt.paramMin &gt;= parts.length)
      throw new etc.ParseError(tmplName, state.line, &quot;statement needs more parameters: &quot; + stmtStr);
    if (stmt.prefixFunc != null)
      funcText.push(stmt.prefixFunc(parts, state, tmplName, etc));
    else
      funcText.push(stmt.prefix);
    if (stmt.suffix != null) {
      if (parts.length &lt;= 1) {
        if (stmt.paramDefault != null)
          funcText.push(stmt.paramDefault);
      } else {
        for (var i = 1; i &lt; parts.length; i++) {
          if (i &gt; 1)
            funcText.push(&#x27; &#x27;);
          funcText.push(parts[i]);
        }
      }
      funcText.push(stmt.suffix);
    }
  }

  var emitSectionText = function(text, funcText) {
    if (text.length &lt;= 0)
      return;
    var nlPrefix = 0;               &#x2F;&#x2F; Index to first non-newline in prefix.
    var nlSuffix = text.length - 1; &#x2F;&#x2F; Index to first non-space&#x2F;tab in suffix.
    while (nlPrefix &lt; text.length &amp;&amp; (text.charAt(nlPrefix) == &#x27;\n&#x27;))
      nlPrefix++;
    while (nlSuffix &gt;= 0 &amp;&amp; (text.charAt(nlSuffix) == &#x27; &#x27; || text.charAt(nlSuffix) == &#x27;\t&#x27;))
      nlSuffix--;
    if (nlSuffix &lt; nlPrefix)
      nlSuffix = nlPrefix;
    if (nlPrefix &gt; 0) {
      funcText.push(&#x27;if (_FLAGS.keepWhitespace == true) _OUT.write(&quot;&#x27;);
      var s = text.substring(0, nlPrefix).replace(&#x27;\n&#x27;, &#x27;\\n&#x27;); &#x2F;&#x2F; A macro IE fix from BJessen.
      if (s.charAt(s.length - 1) == &#x27;\n&#x27;)
        s = s.substring(0, s.length - 1);
      funcText.push(s);
      funcText.push(&#x27;&quot;);&#x27;);
    }
    var lines = text.substring(nlPrefix, nlSuffix + 1).split(&#x27;\n&#x27;);
    for (var i = 0; i &lt; lines.length; i++) {
      emitSectionTextLine(lines[i], funcText);
      if (i &lt; lines.length - 1)
        funcText.push(&#x27;_OUT.write(&quot;\\n&quot;);\n&#x27;);
    }
    if (nlSuffix + 1 &lt; text.length) {
      funcText.push(&#x27;if (_FLAGS.keepWhitespace == true) _OUT.write(&quot;&#x27;);
      var s = text.substring(nlSuffix + 1).replace(&#x27;\n&#x27;, &#x27;\\n&#x27;);
      if (s.charAt(s.length - 1) == &#x27;\n&#x27;)
        s = s.substring(0, s.length - 1);
      funcText.push(s);
      funcText.push(&#x27;&quot;);&#x27;);
    }
  }

  var emitSectionTextLine = function(line, funcText) {
    var endMarkPrev = &#x27;}&#x27;;
    var endExprPrev = -1;
    while (endExprPrev + endMarkPrev.length &lt; line.length) {
      var begMark = &quot;${&quot;, endMark = &quot;}&quot;;
      var begExpr = line.indexOf(begMark, endExprPrev + endMarkPrev.length); &#x2F;&#x2F; In &quot;a${b}c&quot;, begExpr == 1
      if (begExpr &lt; 0)
        break;
      if (line.charAt(begExpr + 2) == &#x27;%&#x27;) {
        begMark = &quot;${%&quot;;
        endMark = &quot;%}&quot;;
      }
      var endExpr = line.indexOf(endMark, begExpr + begMark.length);         &#x2F;&#x2F; In &quot;a${b}c&quot;, endExpr == 4;
      if (endExpr &lt; 0)
        break;
      emitText(line.substring(endExprPrev + endMarkPrev.length, begExpr), funcText);
      &#x2F;&#x2F; Example: exprs == &#x27;firstName|default:&quot;John Doe&quot;|capitalize&#x27;.split(&#x27;|&#x27;)
      var exprArr = line.substring(begExpr + begMark.length, endExpr).replace(&#x2F;\|\|&#x2F;g, &quot;#@@#&quot;).split(&#x27;|&#x27;);
      for (var k in exprArr) {
        if (exprArr[k].replace) &#x2F;&#x2F; IE 5.x fix from Igor Poteryaev.
          exprArr[k] = exprArr[k].replace(&#x2F;#@@#&#x2F;g, &#x27;||&#x27;);
      }
      funcText.push(&#x27;_OUT.write(&#x27;);
      emitExpression(exprArr, exprArr.length - 1, funcText);
      funcText.push(&#x27;);&#x27;);
      endExprPrev = endExpr;
      endMarkPrev = endMark;
    }
    emitText(line.substring(endExprPrev + endMarkPrev.length), funcText);
  }

  var emitText = function(text, funcText) {
    if (text == null ||
      text.length &lt;= 0)
      return;
    text = text.replace(&#x2F;\\&#x2F;g, &#x27;\\\\&#x27;);
    text = text.replace(&#x2F;\n&#x2F;g, &#x27;\\n&#x27;);
    text = text.replace(&#x2F;&quot;&#x2F;g, &#x27;\\&quot;&#x27;);
    funcText.push(&#x27;_OUT.write(&quot;&#x27;);
    funcText.push(text);
    funcText.push(&#x27;&quot;);&#x27;);
  }

  var emitExpression = function(exprArr, index, funcText) {
    &#x2F;&#x2F; Ex: foo|a:x|b:y1,y2|c:z1,z2 is emitted as c(b(a(foo,x),y1,y2),z1,z2)
    var expr = exprArr[index]; &#x2F;&#x2F; Ex: exprArr == [firstName,capitalize,default:&quot;John Doe&quot;]
    if (index &lt;= 0) {          &#x2F;&#x2F; Ex: expr    == &#x27;default:&quot;John Doe&quot;&#x27;
      funcText.push(expr);
      return;
    }
    var parts = expr.split(&#x27;:&#x27;);
    funcText.push(&#x27;_MODIFIERS[&quot;&#x27;);
    funcText.push(parts[0]); &#x2F;&#x2F; The parts[0] is a modifier function name, like capitalize.
    funcText.push(&#x27;&quot;](&#x27;);
    emitExpression(exprArr, index - 1, funcText);
    if (parts.length &gt; 1) {
      funcText.push(&#x27;,&#x27;);
      funcText.push(parts[1]);
    }
    funcText.push(&#x27;)&#x27;);
  }

  var cleanWhiteSpace = function(result) {
    result = result.replace(&#x2F;\t&#x2F;g, &quot;    &quot;);
    result = result.replace(&#x2F;\r\n&#x2F;g, &quot;\n&quot;);
    result = result.replace(&#x2F;\r&#x2F;g, &quot;\n&quot;);
    result = result.replace(&#x2F;^(\s*\S*(\s+\S+)*)\s*$&#x2F;, &#x27;$1&#x27;); &#x2F;&#x2F; Right trim by Igor Poteryaev.
    return result;
  }

  var scrubWhiteSpace = function(result) {
    result = result.replace(&#x2F;^\s+&#x2F;g, &quot;&quot;);
    result = result.replace(&#x2F;\s+$&#x2F;g, &quot;&quot;);
    result = result.replace(&#x2F;\s+&#x2F;g, &quot; &quot;);
    result = result.replace(&#x2F;^(\s*\S*(\s+\S+)*)\s*$&#x2F;, &#x27;$1&#x27;); &#x2F;&#x2F; Right trim by Igor Poteryaev.
    return result;
  }

  &#x2F;&#x2F; The DOM helper functions depend on DOM&#x2F;DHTML, so they only work in a browser.
  &#x2F;&#x2F; However, these are not considered core to the engine.
  &#x2F;&#x2F;
  TrimPath.parseDOMTemplate = function(elementId, optDocument, optEtc) {
    if (optDocument == null)
      optDocument = document;
    var element = optDocument.getElementById(elementId);
    var content = element.value;     &#x2F;&#x2F; Like textarea.value.
    if (content == null)
      content = element.innerHTML; &#x2F;&#x2F; Like textarea.innerHTML.
    content = content.replace(&#x2F;&amp;lt;&#x2F;g, &quot;&lt;&quot;).replace(&#x2F;&amp;gt;&#x2F;g, &quot;&gt;&quot;);
    return TrimPath.parseTemplate(content, elementId, optEtc);
  }

  TrimPath.processDOMTemplate = function(elementId, context, optFlags, optDocument, optEtc) {
    return TrimPath.parseDOMTemplate(elementId, optDocument, optEtc).process(context, optFlags);
  }
})();

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
