<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>bristle-controller.js - Bristleback Client API</title>
    <link rel="stylesheet" href="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;3.7.0&#x2F;build&#x2F;cssgrids&#x2F;cssgrids-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="..&#x2F;assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="..&#x2F;assets/favicon.png">
    <script src="http:&#x2F;&#x2F;yui.yahooapis.com&#x2F;combo?3.7.0&#x2F;build&#x2F;yui&#x2F;yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
            
                <h1><img src="http:&#x2F;&#x2F;bristleback.pl&#x2F;img&#x2F;bristleback-logo-green.png" title="Bristleback Client API"></h1>
            
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: 0.3.5</em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
    <h2 class="off-left">APIs</h2>
    <div id="api-tabview" class="tabview">
        <ul class="tabs">
            <li><a href="#api-classes">Classes</a></li>
            <li><a href="#api-modules">Modules</a></li>
        </ul>

        <div id="api-tabview-filter">
            <input type="search" id="api-filter" placeholder="Type to filter APIs">
        </div>

        <div id="api-tabview-panel">
            <ul id="api-classes" class="apis classes">
            
                <li><a href="..&#x2F;classes/Bristleback.auth.SystemAuthentication.html">Bristleback.auth.SystemAuthentication</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.Client.html">Bristleback.Client</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.controller.Action.html">Bristleback.controller.Action</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.controller.ActionCallback.html">Bristleback.controller.ActionCallback</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.controller.ActionClass.html">Bristleback.controller.ActionClass</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.controller.ActionController.html">Bristleback.controller.ActionController</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.controller.ActionExceptionHandler.html">Bristleback.controller.ActionExceptionHandler</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.controller.ActionMessage.html">Bristleback.controller.ActionMessage</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.controller.ClientActionClass.html">Bristleback.controller.ClientActionClass</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.controller.controllers.html">Bristleback.controller.controllers</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.LOCAL_HOSTNAME.html">Bristleback.LOCAL_HOSTNAME</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.template.TemplateController.html">Bristleback.template.TemplateController</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.USER_CONTEXT.html">Bristleback.USER_CONTEXT</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.USER_DETAILS.html">Bristleback.USER_DETAILS</a></li>
            
                <li><a href="..&#x2F;classes/Bristleback.utils.html">Bristleback.utils</a></li>
            
            </ul>

            <ul id="api-modules" class="apis modules">
            
                <li><a href="..&#x2F;modules/auth.html">auth</a></li>
            
                <li><a href="..&#x2F;modules/Bristleback.html">Bristleback</a></li>
            
                <li><a href="..&#x2F;modules/controller.html">controller</a></li>
            
                <li><a href="..&#x2F;modules/core.html">core</a></li>
            
                <li><a href="..&#x2F;modules/serialization.html">serialization</a></li>
            
                <li><a href="..&#x2F;modules/template.html">template</a></li>
            
                <li><a href="..&#x2F;modules/utils.html">utils</a></li>
            
            </ul>
        </div>
    </div>
</div>

            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
        Show:
        <label for="api-show-inherited">
            <input type="checkbox" id="api-show-inherited" checked>
            Inherited
        </label>

        <label for="api-show-protected">
            <input type="checkbox" id="api-show-protected">
            Protected
        </label>

        <label for="api-show-private">
            <input type="checkbox" id="api-show-private">
            Private
        </label>
        <label for="api-show-deprecated">
            <input type="checkbox" id="api-show-deprecated">
            Deprecated
        </label>

    </div>


            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: bristle-controller.js</h1>

<div class="file">
    <pre class="code prettyprint linenums">
&#x2F;**
 Action controller module

 @module Bristleback
 @submodule controller
 @main Bristleback
 **&#x2F;

&#x2F;**
 * Controllers container map.
 * @static
 * @class controllers
 * @namespace Bristleback.controller
 * @type Object
 *&#x2F;
BB.controller.controllers = {};

&#x2F;**
 * Creates a new action message
 * @param {Object} controller data controller
 * @param {Object} message message to sent
 * @class ActionMessage
 * @namespace Bristleback.controller
 * @constructor
 * @private
 *&#x2F;
BB.controller.ActionMessage = function (controller, message) {
  var messageElements = message.name.split(&quot;:&quot;);
  var actionElements = messageElements[0].split(&quot;.&quot;);
  var actionClassName = actionElements[0];
  var actionName = actionElements[1] ? actionElements[1] : &quot;&quot;;
  if (message.id) {
    this.actionClass = controller.actionClasses[actionClassName];
    this.content = message.payload[0];
  } else {
    this.actionClass = controller.clientActionClasses[actionClassName];
    this.content = message.payload;
  }

  if (this.actionClass == undefined) {
    throw new Error(&quot;[ERROR] Cannot find a client action class \&quot;&quot; + actionClassName + &quot;\&quot;&quot;);
  }

  this.action = this.actionClass.actions[actionName];
  if (this.action == undefined) {
    throw new Error(&quot;[ERROR] Cannot find action &quot; + (actionName ? &quot;\&quot;&quot; + actionName + &quot;\&quot;&quot; : &quot;default action &quot;) + &quot; in action class \&quot;&quot; + actionClassName + &quot;\&quot;&quot;);
  }

  this.callback = controller.callbacks[message.id];
  this.exceptionType = messageElements.length &gt; 1 ? this.content.type : undefined;
};

&#x2F;**
 * Action exception handler class allows to fully control exception handling process.
 * Instance of this class is created for every action, action class, action callback object and
 * also there is one exception handler in action controller object.
 * @class ActionExceptionHandler
 * @namespace Bristleback.controller
 * @constructor
 *&#x2F;
BB.controller.ActionExceptionHandler = function ActionExceptionHandler() {
  this.defaultExceptionHandler = undefined;
  this.defaultRenderingHandler = undefined;
  this.exceptionHandlers = {};
  this.renderingHandlers = {};
};

&#x2F;**
 * Sets a default exception handler function that will be invoked when exception handler for given exception type
 * cannot be found or it has been found and returned &quot;false&quot;.
 * @method setDefaultExceptionHandler
 * @chainable
 * @param {Function} handlerFunction exception handler function reference, containing one parameter, which is actual exception message.
 *&#x2F;
BB.controller.ActionExceptionHandler.prototype.setDefaultExceptionHandler = function (handlerFunction) {
  this.defaultExceptionHandler = handlerFunction;
  return this;
};

&#x2F;**
 * Sets exception handler function applicable for exception type given as first parameter.
 * @method setExceptionHandler
 * @chainable
 * @param {String} exceptionType exception type
 * @param {Function} handlerFunction exception handler function reference, containing one parameter, which is actual exception message.
 *&#x2F;
BB.controller.ActionExceptionHandler.prototype.setExceptionHandler = function (exceptionType, handlerFunction) {
  this.exceptionHandlers[exceptionType] = handlerFunction;
  return this;
};

&#x2F;**
 * Adds rendering handler to be used when given exception type occurs.
 * Before using rendering functionality, templating framework implementation should be provided by calling
 * Bristleback.templateController.registerTemplateFramework() method.
 * Rendering handlers ALWAYS break exception processing cycle.
 * @method renderOnException
 * @chainable
 * @param {String} exceptionType exception type to handle.
 * @param {String} templateName template name that should be used.
 * @param {String} containerId id of the parent container for rendered template.
 * @param {String} renderingMode name of rendering mode, one of the specified in
 * &lt;strong&gt;Bristleback.templateController.renderingModes&lt;&#x2F;strong&gt; map. By default, &quot;replace&quot; mode is used.
 *&#x2F;
BB.controller.ActionExceptionHandler.prototype.renderOnException = function (exceptionType, templateName, containerId, renderingMode) {
  var templateInformation = BB.templateController.constructTemplateInformation(templateName, containerId, &quot;exception&quot;, renderingMode);
  this.renderingHandlers[exceptionType] = function (exceptionMessage) {
    BB.templateController.render(templateInformation, exceptionMessage);
  };
  return this;
};

&#x2F;**
 * Adds default rendering handler to be used when exception occurs.
 * Before using rendering functionality, templating framework implementation should be provided by calling
 * Bristleback.templateController.registerTemplateFramework() method.
 * Rendering handlers ALWAYS break exception processing cycle.
 * @method renderOnDefaultException
 * @chainable
 * @param templateName template name that should be used.
 * @param containerId id of the parent container for rendered template.
 * @param {String} renderingMode name of rendering mode, one of the specified in
 * &lt;strong&gt;Bristleback.templateController.renderingModes&lt;&#x2F;strong&gt; map. By default, &quot;replace&quot; mode is used.
 *&#x2F;
BB.controller.ActionExceptionHandler.prototype.renderOnDefaultException = function (templateName, containerId, renderingMode) {
  var templateInformation = BB.templateController.constructTemplateInformation(templateName, containerId, &quot;exception&quot;, renderingMode);
  this.defaultRenderingHandler = function (exceptionMessage) {
    BB.templateController.render(templateInformation, exceptionMessage);
  };
  return this;
};


BB.controller.ActionExceptionHandler.prototype.handleException = function (exceptionMessage) {
  var chosenHandler = this.exceptionHandlers[exceptionMessage.exceptionType];
  var chosenRenderingHandler = this.renderingHandlers[exceptionMessage.exceptionType];
  var breakChain = false;
  if (chosenHandler) {
    breakChain = chosenHandler(exceptionMessage);
  }
  if (chosenRenderingHandler) {
    breakChain = true;
    chosenRenderingHandler(exceptionMessage);
  }

  return breakChain || this.handleDefault(exceptionMessage);
};

BB.controller.ActionExceptionHandler.prototype.handleDefault = function (exceptionMessage) {
  var breakChain = false;
  if (this.defaultExceptionHandler) {
    breakChain = this.defaultExceptionHandler(exceptionMessage);
  }
  if (this.defaultRenderingHandler) {
    breakChain = true;
    this.defaultRenderingHandler(exceptionMessage);
  }
  return breakChain;
};


&#x2F;&#x2F;------------- ACTION CALLBACK

&#x2F;**
 * This class is the highest level response handler used in server actions.
 * Action callbacks can be placed as last parameter in server action invocations.
 * Action callback contains fields for both normal and exception responses.
 * @class ActionCallback
 * @namespace Bristleback.controller
 * @constructor
 * @param {Function} responseHandler handler function taking one parameter (actual response object from server).
 *&#x2F;
BB.controller.ActionCallback = function (responseHandler) {

  &#x2F;**
   * Handler function taking one parameter (actual response object from server).
   *  This handler is invoked in case when non exceptional response is returned by the server.
   * @property responseHandler
   * @type Function
   *&#x2F;
  this.responseHandler = responseHandler;

  &#x2F;**
   * Exception handler object for specifying reaction for exception responses.
   *
   * @property exceptionHandler
   * @type Bristleback.controller.ActionExceptionHandler
   **&#x2F;
  this.exceptionHandler = new BB.controller.ActionExceptionHandler();
};

BB.controller.ActionCallback.prototype.handleResponse = function (content) {
  return this.responseHandler(content);
};

BB.controller.ActionCallback.prototype.canHandleResponse = function () {
  return this.responseHandler != undefined;
};

&#x2F;&#x2F;------------- ACTION CONTROLLER

&#x2F;**
 * Action controller is a default, built in data controller used in Bristleback Server.
 * Action controller uses server and client action classes to communicate with server.
 * Name of this controller: &#x27;system.controller.action&#x27;. To use action controller,
 * server must have it enabled in configuration.
 * @class ActionController
 * @namespace Bristleback.controller
 * @constructor
 *&#x2F;
BB.controller.ActionController = function () {
  this.client = undefined;
  this.lastId = 1;

  this.actionClasses = {};
  this.clientActionClasses = {};
  this.callbacks = {};

  &#x2F;**
   * Exception handler object for specifying reaction for exception responses.
   *
   * @property exceptionHandler
   * @type Bristleback.controller.ActionExceptionHandler
   **&#x2F;
  this.exceptionHandler = new BB.controller.ActionExceptionHandler();

  this.exceptionHandler.setDefaultExceptionHandler(this.defaultHandlerFunction);

  this.authentication = new BB.auth.SystemAuthentication(this);
};

BB.controller.ActionController.prototype.onMessage = function (message) {
  var actionMessage = new BB.controller.ActionMessage(this, message);
  if (actionMessage.exceptionType) {
    this.onExceptionMessage(actionMessage);
  } else {
    actionMessage.actionClass.onMessage(actionMessage);
  }
};

BB.controller.ActionController.prototype.sendMessage = function (actionClass, action, parameters) {
  var currentId = this.lastId++;
  var messageName = action ? actionClass + &quot;.&quot; + action : actionClass;
  var message = {
    name: messageName,
    payload: parameters,
    id: currentId
  };
  this.client.sendMessage(message);
  return currentId;
};

&#x2F;**
 * Gets a server action class with name given as parameter.
 * If action class doesn&#x27;t exist, this method transparently creates one
 * and immediately returns it.
 * @method getActionClass
 * @param {String} actionClassName name of requested server action class.
 *&#x2F;
BB.controller.ActionController.prototype.getActionClass = function (actionClassName) {
  var actionClass = this.actionClasses[actionClassName];
  if (actionClass === undefined) {
    actionClass = new BB.controller.ActionClass(actionClassName, this);
    this.actionClasses[actionClassName] = actionClass;
  }
  return actionClass;
};

BB.controller.ActionController.prototype.onExceptionMessage = function (exceptionMessage) {
  return (exceptionMessage.callback &amp;&amp; exceptionMessage.callback.exceptionHandler.handleException(exceptionMessage)) ||
    exceptionMessage.action.exceptionHandler.handleException(exceptionMessage) ||
    exceptionMessage.actionClass.exceptionHandler.handleException(exceptionMessage) ||
    this.exceptionHandler.handleException(exceptionMessage);
};

BB.controller.ActionController.prototype.defaultHandlerFunction = function (exceptionMessage) {
  var actionToString = &quot;[&quot; + (exceptionMessage.action.name ? &quot;Action &quot; + exceptionMessage.actionClass.name + &quot;.&quot;
    + exceptionMessage.action.name + &quot;()&quot; : &quot;Default action of class &quot; + exceptionMessage.actionClass.name) + &quot;]&quot;;
  throw new Error(actionToString
    + &quot; returned with exception of type \&quot;&quot; + exceptionMessage.exceptionType + &quot;\&quot; and detail message \&quot;&quot;
    + BB.utils.objectToString(exceptionMessage.content) + &quot;\&quot;&quot;);
};

&#x2F;**
 * Registers given object as client action class.
 * After registration, server is able to invoke methods of given client action class.
 * Client action classes are normal Object instances created in any way.
 * @method registerClientActionClass
 * @param  {String} actionClassName name of client action class
 * @param {Object} actionClass client action class object.
 *&#x2F;
BB.controller.ActionController.prototype.registerClientActionClass = function (actionClassName, actionClass) {
  this.clientActionClasses[actionClassName] = new BB.controller.ClientActionClass(actionClassName, actionClass);
};


&#x2F;&#x2F;------------- ACTION CLASS

&#x2F;**
 * ActionClass is a client representation of server action class defined on Java side.
 * Using this class, user can invoke server actions and specify how to handle normal&#x2F;exception responses.
 * Action class instances should not be created using directly this constructors,
 * but using {{#crossLink &quot;Bristleback.controller.ActionController&#x2F;getActionClass&quot;}}{{&#x2F;crossLink}} method
 *
 * @class ActionClass
 * @namespace Bristleback.controller
 * @constructor
 * @param {String} name name of this action class.
 * @param {Object} actionController
 *&#x2F;
BB.controller.ActionClass = function (name, actionController) {
  this.actionController = actionController;
  this.name = name;
  this.actions = {};

  &#x2F;**
   * Exception handler object for specifying reaction for exception responses.
   *
   * @property exceptionHandler
   * @type Bristleback.controller.ActionExceptionHandler
   **&#x2F;
  this.exceptionHandler = new BB.controller.ActionExceptionHandler();
  this.exceptionHandler.setExceptionHandler(&quot;BrokenActionProtocolException&quot;, this.defaultProtocolExceptionHandlerFunction);
};

&#x2F;**
 * Creates a default action definition for this action class.
 * Default actions don&#x27;t have names (message name consists of action class name only).
 * To invoke default action on server, use {{#crossLink &quot;Bristleback.controller.ActionClass&#x2F;executeDefault&quot;}}{{&#x2F;crossLink}}
 * @method defineDefaultAction
 *&#x2F;
BB.controller.ActionClass.prototype.defineDefaultAction = function () {
  return this.defineAction(&quot;&quot;);
};

&#x2F;**
 * Creates a non default action definition with name given as parameter.
 * In addition, the action controller creates method and attaches it to this action class.
 * User can then invoke created action like any other methods.
 * @method defineAction
 * @param {String} actionName name of action
 *&#x2F;
BB.controller.ActionClass.prototype.defineAction = function (actionName) {
  if (this[actionName] != undefined) {
    throw new Error(&quot;Action &quot; + actionName + &quot; already defined for action class &quot; + this.name);
  }
  this.actions[actionName] = new BB.controller.Action(actionName, this);
  this[actionName] = function () {
    this.doSendMessage(this.actions[actionName], arguments);
  };
  return this.actions[actionName];
};

&#x2F;**
 * Invokes default action of this action class on the server side.
 * Action execution is always asynchronous.
 * Response handler can be specified by setting handler method in
 * {{#crossLink &quot;Bristleback.controller.Action&quot;}}{{&#x2F;crossLink}} object
 * or by adding additional parameter at the end of parameters list.
 * Such additional parameter can be function (which will be used when normal, non exceptional response arrives)
 * or {{#crossLink &quot;Bristleback.USER_CONTEXT&quot;}}{{&#x2F;crossLink}} object.
 * @method executeDefault
 * @param {String} connector user connection placeholder,
 * {{#crossLink &quot;Bristleback.USER_CONTEXT&quot;}}{{&#x2F;crossLink}} constant should be used.
 * @param {Object} payload payload object
 *&#x2F;
BB.controller.ActionClass.prototype.executeDefault = function (connector, payload) {
  var defaultAction = this.actions[&quot;&quot;];
  this.doSendMessage(defaultAction, arguments);
};

&#x2F;**
 * Gets an action definition with name given as parameter.
 * @method getAction
 * @param {String} actionName action name.
 *&#x2F;
BB.controller.ActionClass.prototype.getAction = function (actionName) {
  return this.actions[actionName];
};

&#x2F;**
 * Gets a default action definition.
 * @method getDefaultAction
 *&#x2F;
BB.controller.ActionClass.prototype.getDefaultAction = function () {
  return this.actions[&quot;&quot;];
};

BB.controller.ActionClass.prototype.doSendMessage = function (action, parameters) {
  var correctParameters = [];
  var parametersLength = parameters.length;
  for (var i = 0; i &lt; parametersLength; i++) {
    correctParameters[i] = parameters[i];
  }
  var lastArgument = correctParameters.length == 0 ? undefined : correctParameters[correctParameters.length - 1];
  if (lastArgument != undefined) {
    if (lastArgument instanceof Function) {
      correctParameters.pop();
      var callback = new BB.controller.ActionCallback(lastArgument);
    } else if (lastArgument instanceof BB.controller.ActionCallback) {
      callback = correctParameters.pop();
    }
  }
  var messageId = this.actionController.sendMessage(this.name, action.name, correctParameters);
  if (callback != undefined) {
    this.actionController.callbacks[messageId] = callback;
  }
};

BB.controller.ActionClass.prototype.onMessage = function (actionMessage) {
  if (actionMessage.callback != undefined) {
    this.actionController.callbacks[actionMessage.id] = undefined;
    if (actionMessage.callback.canHandleResponse()) {
      actionMessage.callback.handleResponse(actionMessage.content);
      return;
    }
  }
  this.runHandlers(actionMessage);
};

BB.controller.ActionClass.prototype.runHandlers = function (actionMessage) {
  var action = actionMessage.action;
  if (action.responseHandler == undefined) {
    var actionToString = &quot;[&quot; + (action.name ? &quot;Action &quot; + this.name + &quot;.&quot; + action.name + &quot;()&quot; : &quot;Default action of &quot; + this.name) + &quot;]&quot;;
    throw new Error(actionToString + &quot; Cannot find response handler for incoming action&quot;);
  } else {
    action.responseHandler(actionMessage.content);
  }
  if (action.renderingHandler) {
    action.renderingHandler(actionMessage.content)
  }
};

BB.controller.ActionClass.prototype.defaultProtocolExceptionHandlerFunction = function (exceptionMessage) {
  var protocolViolationType = exceptionMessage.content;
  if (protocolViolationType == &#x27;NO_ACTION_CLASS_FOUND&#x27;) {
    throw new Error(&quot;Cannot find action class with name \&quot;&quot; + exceptionMessage.actionClass.name + &quot;\&quot;&quot;);
  } else {
    return false;
  }
};

&#x2F;&#x2F;------------- ACTION

&#x2F;**
 * This is a single server action definition, created within a server action class.
 * This class provides fluent API for building action behaviour.
 * Constructor of this class should not be used directly by application user.
 * User should rather create action using {{#crossLink &quot;Bristleback.controller.ActionClass&#x2F;defineDefaultAction&quot;}}{{&#x2F;crossLink}}
 * and {{#crossLink &quot;Bristleback.controller.ActionClass&#x2F;defineAction&quot;}}{{&#x2F;crossLink}} .
 * @class Action
 * @namespace Bristleback.controller
 * @param name name of this action
 * @param actionClass action class containing this action
 *&#x2F;
BB.controller.Action = function (name, actionClass) {
  this.name = name;
  this.actionClass = actionClass;

  &#x2F;**
   * Exception handler object for specifying reaction for exception responses.
   *
   * @property exceptionHandler
   * @type Bristleback.controller.ActionExceptionHandler
   **&#x2F;
  this.exceptionHandler = new BB.controller.ActionExceptionHandler();
  this.exceptionHandler.setExceptionHandler(&quot;BrokenActionProtocolException&quot;, this.defaultProtocolExceptionHandlerFunction);
};

&#x2F;**
 * Sets a response handler function for this action.
 * @method setResponseHandler
 * @chainable
 * @param {Function} handler handler function taking one parameter (actual response object from server).
 *&#x2F;
BB.controller.Action.prototype.setResponseHandler = function (handler) {
  this.responseHandler = handler;
  return this;
};

&#x2F;**
 * Sets a rendering response handler function for this action.
 * If there is another response handler defined for this action (by invoking setResponseHandler() method),
 * rendering handler function runs after that response handler, so normal handler can modify or prepare action response.
 * @method renderOnResponse
 * @chainable
 * @param {String} templateName template name that should be used.
 * @param {String} containerId id of the parent container for rendered template.
 * @param {String} rootObjectName if specified,
 * template controller will prepare literal object containing property with name given by this parameter
 * and value returned by server.
 * @param {String} renderingMode name of rendering mode, one of the specified in
 * &lt;strong&gt;Bristleback.templateController.renderingModes&lt;&#x2F;strong&gt; map. By default, &quot;replace&quot; mode is used.
 *&#x2F;
BB.controller.Action.prototype.renderOnResponse = function (templateName, containerId, rootObjectName, renderingMode) {
  var templateInformation = BB.templateController.constructTemplateInformation(templateName, containerId, rootObjectName, renderingMode);

  this.renderingHandler = function (actionMessage) {
    BB.templateController.render(templateInformation, actionMessage);
  };
  return this;
};

BB.controller.Action.prototype.defaultProtocolExceptionHandlerFunction = function (exceptionMessage) {
  var protocolViolationType = exceptionMessage.content;
  if (protocolViolationType == &#x27;NO_DEFAULT_ACTION_FOUND&#x27;) {
    var exceptionMessageString = &quot;Cannot find default action in action class with name \&quot;&quot; + exceptionMessage.actionClass.name + &quot;\&quot;&quot;;
  } else if (protocolViolationType == &#x27;NO_ACTION_FOUND&#x27;) {
    exceptionMessageString = &quot;Cannot find action \&quot;&quot; + exceptionMessage.action.name + &quot;\&quot; in action class with name \&quot;&quot; + exceptionMessage.actionClass.name + &quot;\&quot;&quot;;
  } else {
    return false;
  }
  throw new Error(exceptionMessageString);
};

&#x2F;&#x2F;------------- CLIENT ACTION CLASS

&#x2F;**
 * This is a client action class definition.
 * Instances of this class should be created directly by application user.
 * Instead, they can use {{#crossLink &quot;Bristleback.controller.ActionController&#x2F;registerClientActionClass&quot;}}{{&#x2F;crossLink}}
 * @class ClientActionClass
 * @namespace Bristleback.controller
 * @constructor
 * @param {String} name name of this client action class
 * @param {Object} actionClass real client action class instance.
 *&#x2F;
BB.controller.ClientActionClass = function (name, actionClass) {
  this.name = name;
  this.actions = actionClass;
};

BB.controller.ClientActionClass.prototype.onMessage = function (actionMessage) {
  actionMessage.action.apply(actionMessage.actionClass, actionMessage.content);
};

&#x2F;&#x2F;------------- DEFAULT CONTROLLERS

BB.controller.controllers[&quot;system.controller.action&quot;] = BB.controller.ActionController;

    </pre>
</div>

                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="..&#x2F;assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="..&#x2F;assets/js/yui-prettify.js"></script>
<script src="..&#x2F;assets/../api.js"></script>
<script src="..&#x2F;assets/js/api-filter.js"></script>
<script src="..&#x2F;assets/js/api-list.js"></script>
<script src="..&#x2F;assets/js/api-search.js"></script>
<script src="..&#x2F;assets/js/apidocs.js"></script>
</body>
</html>
